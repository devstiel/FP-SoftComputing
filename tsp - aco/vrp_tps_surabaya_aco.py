# -*- coding: utf-8 -*-
"""VRP - TPS SURABAYA - ACO

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ptpYpG319_geBqxM_6w5gOQvhOnEfLC7

# VRP SBY PUSAT WITH BENOWOOO
"""

import pandas as pd
import numpy as np
import random
from sklearn.cluster import KMeans
import folium
import math

df = pd.read_csv('SURABAYA BENOWO TPS.csv')
df

df['lat'] = df['Latitude'].astype(str).str.replace('–','-').astype(float)
df['lon'] = df['Longitude'].astype(str).str.replace('–','-').astype(float)
df

# 3. Define depot (Pool) and TPA coordinates
pool = (-7.26053139, 112.692194)   # Pool Tanjungsari
tpa  = (-7.23739100, 112.60943600) # TPA Benowo

df['lat'] = df['Latitude'].astype(str).str.replace('–','-').astype(float)
df['lon'] = df['Longitude'].astype(str).str.replace('–','-').astype(float)
df

# 5. Cluster into number of arm-roll trucks (HCS)
n_vehicles = 11
coords = df[['lat','lon']].values
kmeans = KMeans(n_clusters=n_vehicles, random_state=42).fit(coords)
df['cluster'] = kmeans.labels_

#Clustering Folium Visualization

# Define a color map for clusters
colors = ['blue', 'purple', 'orange', 'darkred', 'lightred', 'darkblue', 'darkgreen', 'cadetblue', 'darkpurple', 'pink', 'lightblue']

# Create a new map centered at the pool
m_cluster = folium.Map(location=pool, zoom_start=12)

# Add depot and TPA markers
folium.Marker(location=pool, popup='Pool Tanjungsari', icon=folium.Icon(color='red')).add_to(m_cluster)
folium.Marker(location=tpa, popup='TPA Benowo', icon=folium.Icon(color='green')).add_to(m_cluster)

# Add markers for each point, colored by cluster
for _, row in df.iterrows():
    folium.Marker(location=(row['lat'], row['lon']),
                  popup=f"{row['LPS/Depo']} (Cluster {row['cluster']})",
                  icon=folium.Icon(color=colors[row['cluster'] % len(colors)])).add_to(m_cluster)

# Display the map
m_cluster

# 6. Utility functions for GA-based TSP
def haversine(a, b):
    R = 6371e3
    φ1, φ2 = math.radians(a[0]), math.radians(b[0])
    Δφ = math.radians(b[0] - a[0])
    Δλ = math.radians(b[1] - a[1])
    x = math.sin(Δφ/2)**2 + math.cos(φ1)*math.cos(φ2)*math.sin(Δλ/2)**2
    return R * 2 * math.asin(math.sqrt(x))

def route_distance(route):
    dist = 0
    prev = pool
    for pt in route:
        dist += haversine(prev, pt)
        prev = pt
    dist += haversine(prev, tpa) + haversine(tpa, pool)
    return dist

def order_crossover(p1, p2):
    size = len(p1)
    a, b = sorted(random.sample(range(size), 2))
    c1 = [None]*size
    c2 = [None]*size
    c1[a:b], c2[a:b] = p1[a:b], p2[a:b]
    def fill(child, parent):
        pos = b
        for gene in parent[b:] + parent[:b]:
            if gene not in child:
                if pos >= size: pos = 0
                child[pos] = gene
                pos += 1
    fill(c1, p2)
    fill(c2, p1)
    return c1, c2

def mutate(ind):
    if len(ind) > 1:
        i, j = random.sample(range(len(ind)), 2)
        ind[i], ind[j] = ind[j], ind[i]

def ga_cluster(points, pop_size=200, gens=1000, elite_size=1):
    n = len(points)
    if n < 2:
        return points

    # initialize population
    population = [random.sample(range(n), n) for _ in range(pop_size)]

    for _ in range(gens):
        # compute fitness for roulette selection
        fitness = [1/(route_distance([points[i] for i in ind]) + 1) for ind in population]
        total = sum(fitness)
        probs = [f/total for f in fitness]

        # select elites (best individuals) to carry forward
        sorted_pop = sorted(
            population,
            key=lambda ind: route_distance([points[i] for i in ind])
        )
        new_pop = [sorted_pop[i].copy() for i in range(elite_size)]

        # fill the rest of new_pop by crossover + mutation
        while len(new_pop) < pop_size:
            # select two parents
            p1, p2 = random.choices(population, probs, k=2)
            # crossover
            if random.random() < 0.8:
                c1, c2 = order_crossover(p1, p2)
            else:
                c1, c2 = p1[:], p2[:]
            # mutate
            if random.random() < 0.2:
                mutate(c1)
            if random.random() < 0.2:
                mutate(c2)

            new_pop.append(c1)
            if len(new_pop) < pop_size:
                new_pop.append(c2)

        population = new_pop

    # return the best route as actual coordinates
    best = min(
        population,
        key=lambda ind: route_distance([points[i] for i in ind])
    )
    return [points[i] for i in best]

# 7. Compute and display GA-based VRP routes
m2 = folium.Map(location=pool, zoom_start=12)
folium.Marker(location=pool, popup='Pool Tanjungsari', icon=folium.Icon(color='red')).add_to(m2)
folium.Marker(location=tpa, popup='TPA Benowo', icon=folium.Icon(color='green')).add_to(m2)

colors = [
    'blue','green','purple','orange','darkred',
    'cadetblue','darkgreen','pink','lightgray',
    'beige','darkblue'
]
coord_to_name = {
    (row['lat'], row['lon']): row['LPS/Depo']
    for _, row in df.iterrows()
}
coord_to_name[pool] = "Pool Tanjungsari"
coord_to_name[tpa]  = "TPA Benowo"

for vid in range(n_vehicles):
    # get the raw coordinates in this cluster
    cluster_pts = coords[kmeans.labels_ == vid]
    if len(cluster_pts) == 0:
        continue

    # GA wants a Python list of tuple‐points
    pts_list = [tuple(pt) for pt in cluster_pts]

    # find best ordering of stops
    best_route = ga_cluster(pts_list)

    # build the full trip for plotting
    full_route = [pool] + best_route + [tpa, pool]

    # 1) draw it on the map
    folium.PolyLine(
        locations=full_route,
        color=colors[vid % len(colors)],
        weight=2.5, opacity=0.8,
        popup=f'Vehicle {vid+1}'
    ).add_to(m2)

    # 2) compute the true total distance via route_distance(best_route)
    #    (it already adds pool→stops→TPA→pool)
    total_dist_km = route_distance(best_route) / 1000

    # 3) map coords back to names
    path_names = [coord_to_name[c] for c in full_route]
    print(f"Vehicle {vid+1}: " + " → ".join(path_names))
    print(f"  Total distance: {total_dist_km:.2f} km\n")

# finally show the map
m2


"""# Ant Colony"""

# Load kapasitas truk
df_truk = pd.read_csv('kapasitas-truk.csv', sep = ';')
df_truk

# Fungsi Ant Colony Optimization sederhana
def ant_colony_tsp(points, n_ants=20, n_iterations=100, alpha=1, beta=2, evaporation=0.5):
    n = len(points)
    dist_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                dist_matrix[i][j] = haversine(points[i], points[j])
            else:
                dist_matrix[i][j] = 1e-6  # avoid divide by zero

    pheromone = np.ones((n, n))
    best_distance = float('inf')
    best_path = []

    for _ in range(n_iterations):
        all_paths = []
        all_lengths = []

        for _ in range(n_ants):
            unvisited = list(range(n))
            start = random.choice(unvisited)
            path = [start]
            unvisited.remove(start)

            while unvisited:
                curr = path[-1]
                probs = []
                for j in unvisited:
                    tau = pheromone[curr][j] ** alpha
                    eta = (1 / dist_matrix[curr][j]) ** beta
                    probs.append(tau * eta)
                probs = np.array(probs)
                probs /= probs.sum()
                next_node = np.random.choice(unvisited, p=probs)
                path.append(next_node)
                unvisited.remove(next_node)

            length = sum(dist_matrix[path[i]][path[i + 1]] for i in range(n - 1))
            length += haversine(pool, points[path[0]])  # pool to start
            length += haversine(points[path[-1]], tpa)  # end to TPA
            length += haversine(tpa, pool)             # TPA to pool

            all_paths.append(path)
            all_lengths.append(length)

        shortest_idx = np.argmin(all_lengths)
        if all_lengths[shortest_idx] < best_distance:
            best_distance = all_lengths[shortest_idx]
            best_path = all_paths[shortest_idx]

        # Update pheromone
        pheromone *= (1 - evaporation)
        for path, length in zip(all_paths, all_lengths):
            for i in range(n - 1):
                pheromone[path[i]][path[i + 1]] += 1 / length

    return [points[i] for i in best_path], best_distance

# Map baru ACO
m3 = folium.Map(location=pool, zoom_start=12)
folium.Marker(location=pool, popup='Pool Tanjungsari', icon=folium.Icon(color='red')).add_to(m3)
folium.Marker(location=tpa, popup='TPA Benowo', icon=folium.Icon(color='green')).add_to(m3)

# Map koordinat ke kapasitas
coord_to_capacity = {
    (row['Latitude'], row['Longitude']): row['Kapasitas_Sampah(m^3)']
    for _, row in df.iterrows()
}

for vid in range(n_vehicles):
    cluster_pts = coords[kmeans.labels_ == vid]
    if len(cluster_pts) == 0:
        continue

    pts_list = [tuple(pt) for pt in cluster_pts]
    capacities = [coord_to_capacity[pt] for pt in pts_list]
    total_volume = sum(capacities)

    # Pilih truk terkecil yang muat
    truk_terpilih = None
    for _, row in df_truk.iterrows():
        if total_volume <= row['Volume (m^3)']:
            truk_terpilih = row
            break
    if truk_terpilih is None:
        truk_terpilih = df_truk.iloc[-1]  # Gunakan terbesar jika semuanya tidak cukup

    # ACO untuk rute terbaik
    best_path, best_dist = ant_colony_tsp(pts_list)

    # Bangun rute lengkap
    full_route = [pool] + best_path + [tpa, pool]
    color = colors[vid % len(colors)]
    folium.PolyLine(locations=full_route, color=color, weight=2.5,
                    opacity=0.8, popup=f'Vehicle {vid+1}').add_to(m3)

    path_names = [coord_to_name.get(c, 'Unknown') for c in full_route]

    print(f"[ACO] Vehicle {vid+1}: " + " → ".join(path_names))
    print(f"  Total distance: {best_dist/1000:.2f} km")
    print(f"  Total volume sampah: {total_volume:.1f} m^3")
    print(f"  Jenis truk yang digunakan: {truk_terpilih['Jenis Kendaraan']} (kapasitas {truk_terpilih['Volume (m^3)']} m^3)\n")

# Tampilkan map
m3